{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _jsxFileName = \"/Users/asha/Documents/miniboss/node_modules/@react-native-mapbox-gl/maps/javascript/components/Style.js\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useMemo, useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport CircleLayer from \"./CircleLayer\";\nimport RasterLayer from \"./RasterLayer\";\nimport SymbolLayer from \"./SymbolLayer\";\nimport LineLayer from \"./LineLayer\";\nimport FillLayer from \"./FillLayer\";\nimport FillExtrusionLayer from \"./FillExtrusionLayer\";\nimport BackgroundLayer from \"./BackgroundLayer\";\nimport HeatmapLayer from \"./HeatmapLayer\";\nimport VectorSource from \"./VectorSource\";\nimport RasterSource from \"./RasterSource\";\nimport ImageSource from \"./ImageSource\";\nimport ShapeSource from \"./ShapeSource\";\n\nfunction toCamelCase(s) {\n  return s.replace(/([-_][a-z])/gi, function ($1) {\n    return $1.toUpperCase().replace('-', '').replace('_', '');\n  });\n}\n\nfunction toCamelCaseKeys(oldObj) {\n  if (!oldObj) {\n    return {};\n  }\n\n  var newObj = {};\n  Object.keys(oldObj).forEach(function (key) {\n    var value = oldObj[key];\n\n    if (key.includes('-')) {\n      newObj[toCamelCase(key)] = value;\n    } else {\n      newObj[key] = value;\n    }\n  });\n  return newObj;\n}\n\nfunction getLayerComponentType(layer) {\n  var type = layer.type;\n\n  switch (type) {\n    case 'circle':\n      return CircleLayer;\n\n    case 'symbol':\n      return SymbolLayer;\n\n    case 'raster':\n      return RasterLayer;\n\n    case 'line':\n      return LineLayer;\n\n    case 'fill':\n      return FillLayer;\n\n    case 'fill-extrusion':\n      return FillExtrusionLayer;\n\n    case 'background':\n      return BackgroundLayer;\n\n    case 'heatmap':\n      return HeatmapLayer;\n  }\n\n  console.warn(\"Mapbox layer type '\" + type + \"' is not supported/\");\n  return null;\n}\n\nfunction asLayerComponent(layer) {\n  var LayerComponent = getLayerComponentType(layer);\n\n  if (!LayerComponent) {\n    return null;\n  }\n\n  var style = _objectSpread(_objectSpread({}, toCamelCaseKeys(layer.paint)), toCamelCaseKeys(layer.layout));\n\n  var layerProps = {};\n\n  if (layer.source) {\n    layerProps.sourceID = layer.source;\n  }\n\n  if (layer['source-layer']) {\n    layerProps.sourceLayerID = layer['source-layer'];\n  }\n\n  if (layer.minzoom) {\n    layerProps.minZoomLevel = layer.minzoom;\n  }\n\n  if (layer.maxzoom) {\n    layerProps.maxZoomLevel = layer.maxzoom;\n  }\n\n  if (layer.filter) {\n    layerProps.filter = layer.filter;\n  }\n\n  if (Object.keys(style).length) {\n    layerProps.style = style;\n  }\n\n  return React.createElement(LayerComponent, _extends({\n    key: layer.id,\n    id: layer.id\n  }, layerProps, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 100,\n      columnNumber: 10\n    }\n  }));\n}\n\nfunction getTileSourceProps(source) {\n  var sourceProps = {};\n\n  if (source.url) {\n    sourceProps.url = source.url;\n  }\n\n  if (source.tiles) {\n    sourceProps.tileUrlTemplates = source.tiles;\n  }\n\n  if (source.minzoom !== undefined) {\n    sourceProps.minZoomLevel = source.minzoom;\n  }\n\n  if (source.maxzoom !== undefined) {\n    sourceProps.maxZoomLevel = source.maxzoom;\n  }\n\n  if (source.attribution) {\n    sourceProps.attribution = source.attribution;\n  }\n\n  if (source.scheme && source.scheme === 'tms') {\n    sourceProps.tms = true;\n  }\n\n  return sourceProps;\n}\n\nfunction getVectorSource(id, source) {\n  var sourceProps = _objectSpread({}, getTileSourceProps(source));\n\n  return React.createElement(VectorSource, _extends({\n    key: id,\n    id: id\n  }, sourceProps, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 128,\n      columnNumber: 10\n    }\n  }));\n}\n\nfunction getRasterSource(id, source) {\n  var sourceProps = _objectSpread({}, getTileSourceProps(source));\n\n  if (source.tileSize) {\n    sourceProps.tileSize = source.tileSize;\n  }\n\n  return React.createElement(RasterSource, _extends({\n    key: id,\n    id: id\n  }, sourceProps, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 136,\n      columnNumber: 10\n    }\n  }));\n}\n\nfunction getImageSource(id, source) {\n  var sourceProps = {\n    url: source.url,\n    coordinates: source.coordinates\n  };\n  return React.createElement(ImageSource, _extends({\n    key: id,\n    id: id\n  }, sourceProps, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 144,\n      columnNumber: 10\n    }\n  }));\n}\n\nfunction getShapeSource(id, source) {\n  var sourceProps = {};\n\n  if (source.data && typeof source.data === 'string') {\n    sourceProps.url = source.data;\n  } else if (source.data && typeof source.data === 'object') {\n    sourceProps.shape = source.data;\n  }\n\n  if (source.cluster !== undefined) {\n    sourceProps.cluster = source.cluster;\n  }\n\n  if (source.clusterRadius !== undefined) {\n    sourceProps.clusterRadius = source.clusterRadius;\n  }\n\n  if (source.maxzoom !== undefined) {\n    sourceProps.maxZoomLevel = source.maxzoom;\n  }\n\n  if (source.clusterMaxZoom !== undefined) {\n    sourceProps.clusterMaxZoomLevel = source.clusterMaxZoom;\n  }\n\n  if (source.buffer !== undefined) {\n    sourceProps.buffer = source.buffer;\n  }\n\n  if (source.tolerance !== undefined) {\n    sourceProps.tolerance = source.tolerance;\n  }\n\n  return React.createElement(ShapeSource, _extends({\n    key: id,\n    id: id\n  }, sourceProps, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 172,\n      columnNumber: 10\n    }\n  }));\n}\n\nfunction asSourceComponent(id, source) {\n  switch (source.type) {\n    case 'vector':\n      return getVectorSource(id, source);\n\n    case 'raster':\n      return getRasterSource(id, source);\n\n    case 'image':\n      return getImageSource(id, source);\n\n    case 'geojson':\n      return getShapeSource(id, source);\n  }\n\n  console.warn(\"Mapbox source type '\" + source.type + \"' is not supported/\");\n  return null;\n}\n\nvar Style = function Style(props) {\n  var _useState = useState({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      fetchedJson = _useState2[0],\n      setFetchedJson = _useState2[1];\n\n  var json = typeof props.json === 'object' ? props.json : fetchedJson;\n  useEffect(function () {\n    var abortController = new window.AbortController();\n\n    var fetchStyleJson = function fetchStyleJson() {\n      var response, responseJson;\n      return _regeneratorRuntime.async(function fetchStyleJson$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(fetch(props.json, {\n                signal: abortController.signal\n              }));\n\n            case 3:\n              response = _context.sent;\n              _context.next = 6;\n              return _regeneratorRuntime.awrap(response.json());\n\n            case 6:\n              responseJson = _context.sent;\n              setFetchedJson(responseJson);\n              _context.next = 15;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](0);\n\n              if (!(_context.t0.name === 'AbortError')) {\n                _context.next = 14;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 14:\n              throw _context.t0;\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, [[0, 10]], Promise);\n    };\n\n    if (typeof props.json === 'string') {\n      fetchStyleJson();\n    }\n\n    return function cleanup() {\n      abortController.abort();\n    };\n  }, [props.json]);\n  var layerComponents = useMemo(function () {\n    if (!json.layers) {\n      return [];\n    }\n\n    return json.layers.map(asLayerComponent).filter(function (x) {\n      return !!x;\n    });\n  }, [json.layers]);\n  var sourceComponents = useMemo(function () {\n    if (!json.sources || !Object.keys(json.sources)) {\n      return [];\n    }\n\n    return Object.keys(json.sources).map(function (id) {\n      return asSourceComponent(id, json.sources[id]);\n    }).filter(function (x) {\n      return !!x;\n    });\n  }, [json.sources]);\n  return React.createElement(React.Fragment, null, sourceComponents, layerComponents);\n};\n\nStyle.propTypes = {\n  json: PropTypes.any\n};\nexport default Style;","map":{"version":3,"sources":["/Users/asha/Documents/miniboss/node_modules/@react-native-mapbox-gl/maps/javascript/components/Style.js"],"names":["React","useMemo","useState","useEffect","PropTypes","CircleLayer","RasterLayer","SymbolLayer","LineLayer","FillLayer","FillExtrusionLayer","BackgroundLayer","HeatmapLayer","VectorSource","RasterSource","ImageSource","ShapeSource","toCamelCase","s","replace","$1","toUpperCase","toCamelCaseKeys","oldObj","newObj","Object","keys","forEach","key","value","includes","getLayerComponentType","layer","type","console","warn","asLayerComponent","LayerComponent","style","paint","layout","layerProps","source","sourceID","sourceLayerID","minzoom","minZoomLevel","maxzoom","maxZoomLevel","filter","length","id","getTileSourceProps","sourceProps","url","tiles","tileUrlTemplates","undefined","attribution","scheme","tms","getVectorSource","getRasterSource","tileSize","getImageSource","coordinates","getShapeSource","data","shape","cluster","clusterRadius","clusterMaxZoom","clusterMaxZoomLevel","buffer","tolerance","asSourceComponent","Style","props","fetchedJson","setFetchedJson","json","abortController","window","AbortController","fetchStyleJson","fetch","signal","response","responseJson","name","cleanup","abort","layerComponents","layers","map","x","sourceComponents","sources","propTypes","any"],"mappings":"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","sourcesContent":["import React, {useMemo, useState, useEffect} from 'react';\nimport PropTypes from 'prop-types';\n\nimport CircleLayer from './CircleLayer';\nimport RasterLayer from './RasterLayer';\nimport SymbolLayer from './SymbolLayer';\nimport LineLayer from './LineLayer';\nimport FillLayer from './FillLayer';\nimport FillExtrusionLayer from './FillExtrusionLayer';\nimport BackgroundLayer from './BackgroundLayer';\nimport HeatmapLayer from './HeatmapLayer';\nimport VectorSource from './VectorSource';\nimport RasterSource from './RasterSource';\nimport ImageSource from './ImageSource';\nimport ShapeSource from './ShapeSource';\n\nfunction toCamelCase(s) {\n  return s.replace(/([-_][a-z])/gi, ($1) => {\n    return $1.toUpperCase().replace('-', '').replace('_', '');\n  });\n}\n\n// Patches the Mapbox Style Specification keys into the style props attributes:\n// icon-allow-overlap -> iconAllowOverlap\nfunction toCamelCaseKeys(oldObj) {\n  if (!oldObj) {\n    return {};\n  }\n  const newObj = {};\n  Object.keys(oldObj).forEach((key) => {\n    const value = oldObj[key];\n    if (key.includes('-')) {\n      newObj[toCamelCase(key)] = value;\n    } else {\n      newObj[key] = value;\n    }\n  });\n  return newObj;\n}\n\nfunction getLayerComponentType(layer) {\n  const {type} = layer;\n\n  switch (type) {\n    case 'circle':\n      return CircleLayer;\n    case 'symbol':\n      return SymbolLayer;\n    case 'raster':\n      return RasterLayer;\n    case 'line':\n      return LineLayer;\n    case 'fill':\n      return FillLayer;\n    case 'fill-extrusion':\n      return FillExtrusionLayer;\n    case 'background':\n      return BackgroundLayer;\n    case 'heatmap':\n      return HeatmapLayer;\n  }\n\n  console.warn(`Mapbox layer type '${type}' is not supported/`);\n\n  return null;\n}\n\nfunction asLayerComponent(layer) {\n  const LayerComponent = getLayerComponentType(layer);\n  if (!LayerComponent) {\n    return null;\n  }\n\n  const style = {\n    ...toCamelCaseKeys(layer.paint),\n    ...toCamelCaseKeys(layer.layout),\n  };\n\n  const layerProps = {};\n\n  if (layer.source) {\n    layerProps.sourceID = layer.source;\n  }\n  if (layer['source-layer']) {\n    layerProps.sourceLayerID = layer['source-layer'];\n  }\n  if (layer.minzoom) {\n    layerProps.minZoomLevel = layer.minzoom;\n  }\n  if (layer.maxzoom) {\n    layerProps.maxZoomLevel = layer.maxzoom;\n  }\n  if (layer.filter) {\n    layerProps.filter = layer.filter;\n  }\n  if (Object.keys(style).length) {\n    layerProps.style = style;\n  }\n\n  return <LayerComponent key={layer.id} id={layer.id} {...layerProps} />;\n}\n\nfunction getTileSourceProps(source) {\n  const sourceProps = {};\n  if (source.url) {\n    sourceProps.url = source.url;\n  }\n  if (source.tiles) {\n    sourceProps.tileUrlTemplates = source.tiles;\n  }\n  if (source.minzoom !== undefined) {\n    sourceProps.minZoomLevel = source.minzoom;\n  }\n  if (source.maxzoom !== undefined) {\n    sourceProps.maxZoomLevel = source.maxzoom;\n  }\n  if (source.attribution) {\n    sourceProps.attribution = source.attribution;\n  }\n  if (source.scheme && source.scheme === 'tms') {\n    sourceProps.tms = true;\n  }\n  return sourceProps;\n}\n\nfunction getVectorSource(id, source) {\n  const sourceProps = {...getTileSourceProps(source)};\n  return <VectorSource key={id} id={id} {...sourceProps} />;\n}\n\nfunction getRasterSource(id, source) {\n  const sourceProps = {...getTileSourceProps(source)};\n  if (source.tileSize) {\n    sourceProps.tileSize = source.tileSize;\n  }\n  return <RasterSource key={id} id={id} {...sourceProps} />;\n}\n\nfunction getImageSource(id, source) {\n  const sourceProps = {\n    url: source.url,\n    coordinates: source.coordinates,\n  };\n  return <ImageSource key={id} id={id} {...sourceProps} />;\n}\n\nfunction getShapeSource(id, source) {\n  const sourceProps = {};\n  if (source.data && typeof source.data === 'string') {\n    sourceProps.url = source.data;\n  } else if (source.data && typeof source.data === 'object') {\n    sourceProps.shape = source.data;\n  }\n  if (source.cluster !== undefined) {\n    sourceProps.cluster = source.cluster;\n  }\n  if (source.clusterRadius !== undefined) {\n    sourceProps.clusterRadius = source.clusterRadius;\n  }\n  if (source.maxzoom !== undefined) {\n    sourceProps.maxZoomLevel = source.maxzoom;\n  }\n  if (source.clusterMaxZoom !== undefined) {\n    sourceProps.clusterMaxZoomLevel = source.clusterMaxZoom;\n  }\n  if (source.buffer !== undefined) {\n    sourceProps.buffer = source.buffer;\n  }\n  if (source.tolerance !== undefined) {\n    sourceProps.tolerance = source.tolerance;\n  }\n  return <ShapeSource key={id} id={id} {...sourceProps} />;\n}\n\nfunction asSourceComponent(id, source) {\n  switch (source.type) {\n    case 'vector':\n      return getVectorSource(id, source);\n    case 'raster':\n      return getRasterSource(id, source);\n    case 'image':\n      return getImageSource(id, source);\n    case 'geojson':\n      return getShapeSource(id, source);\n  }\n\n  console.warn(`Mapbox source type '${source.type}' is not supported/`);\n\n  return null;\n}\n\n/**\n * Style is a component that automatically adds sources / layers to the map using Mapbox GL Style Spec.\n * Only [`sources`](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources) & [`layers`](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/) are supported.\n * Other fields such as `sprites`, `glyphs` etc. will be ignored. Not all layer / source attributes from the style spec are supported, in general the supported attributes will mentioned under https://github.com/react-native-mapbox-gl/maps/tree/master/docs.\n */\nconst Style = (props) => {\n  const [fetchedJson, setFetchedJson] = useState({});\n  const json = typeof props.json === 'object' ? props.json : fetchedJson;\n\n  // Fetch style when props.json is a URL\n  useEffect(() => {\n    const abortController = new window.AbortController();\n    const fetchStyleJson = async () => {\n      try {\n        const response = await fetch(props.json, {\n          signal: abortController.signal,\n        });\n        const responseJson = await response.json();\n        setFetchedJson(responseJson);\n      } catch (e) {\n        if (e.name === 'AbortError') {\n          return;\n        }\n        throw e;\n      }\n    };\n    if (typeof props.json === 'string') {\n      fetchStyleJson();\n    }\n    return function cleanup() {\n      abortController.abort();\n    };\n  }, [props.json]);\n\n  // Extract layer components from json\n  const layerComponents = useMemo(() => {\n    if (!json.layers) {\n      return [];\n    }\n    return json.layers.map(asLayerComponent).filter((x) => !!x);\n  }, [json.layers]);\n\n  // Extract source components from json\n  const sourceComponents = useMemo(() => {\n    if (!json.sources || !Object.keys(json.sources)) {\n      return [];\n    }\n    return Object.keys(json.sources)\n      .map((id) => asSourceComponent(id, json.sources[id]))\n      .filter((x) => !!x);\n  }, [json.sources]);\n\n  return (\n    <>\n      {sourceComponents}\n      {layerComponents}\n    </>\n  );\n};\n\nStyle.propTypes = {\n  /**\n   * A JSON object conforming to the schema described in the Mapbox Style Specification , or a URL to such JSON.\n   */\n  json: PropTypes.any,\n};\n\nexport default Style;\n"]},"metadata":{},"sourceType":"module"}