{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/asha/Documents/miniboss/node_modules/@react-native-mapbox-gl/maps/javascript/components/Camera.js\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport { requireNativeComponent } from \"react-native-web/dist/index\";\nimport { toJSONString, viewPropTypes, existenceChange } from \"../utils\";\nimport * as geoUtils from \"../utils/geoUtils\";\nvar MapboxGL = NativeModules.MGLModule;\nexport var NATIVE_MODULE_NAME = 'RCTMGLCamera';\nvar SettingsPropTypes = {\n  centerCoordinate: PropTypes.arrayOf(PropTypes.number),\n  heading: PropTypes.number,\n  pitch: PropTypes.number,\n  bounds: PropTypes.shape({\n    ne: PropTypes.arrayOf(PropTypes.number).isRequired,\n    sw: PropTypes.arrayOf(PropTypes.number).isRequired,\n    paddingLeft: PropTypes.number,\n    paddingRight: PropTypes.number,\n    paddingTop: PropTypes.number,\n    paddingBottom: PropTypes.number,\n    onUserTrackingModeChange: PropTypes.func\n  }),\n  zoomLevel: PropTypes.number\n};\n\nvar Camera = function (_React$Component) {\n  _inherits(Camera, _React$Component);\n\n  var _super = _createSuper(Camera);\n\n  function Camera() {\n    _classCallCheck(this, Camera);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Camera, [{\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      this._handleCameraChange(this.props, nextProps);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate() {\n      return false;\n    }\n  }, {\n    key: \"_handleCameraChange\",\n    value: function _handleCameraChange(currentCamera, nextCamera) {\n      var hasCameraChanged = this._hasCameraChanged(currentCamera, nextCamera);\n\n      if (!hasCameraChanged) {\n        return;\n      }\n\n      if (currentCamera.followUserLocation && !nextCamera.followUserLocation) {\n        this.refs.camera.setNativeProps({\n          followUserLocation: false\n        });\n        return;\n      }\n\n      if (!currentCamera.followUserLocation && nextCamera.followUserLocation) {\n        this.refs.camera.setNativeProps({\n          followUserLocation: true\n        });\n      }\n\n      if (nextCamera.followUserLocation) {\n        this.refs.camera.setNativeProps({\n          followUserMode: nextCamera.followUserMode,\n          followPitch: nextCamera.followPitch || nextCamera.pitch,\n          followHeading: nextCamera.followHeading || nextCamera.heading,\n          followZoomLevel: nextCamera.followZoomLevel || nextCamera.zoomLevel\n        });\n        return;\n      }\n\n      var cameraConfig = {\n        animationMode: nextCamera.animationMode,\n        animationDuration: nextCamera.animationDuration,\n        zoomLevel: nextCamera.zoomLevel,\n        pitch: nextCamera.pitch,\n        heading: nextCamera.heading\n      };\n\n      if (nextCamera.bounds && this._hasBoundsChanged(currentCamera, nextCamera)) {\n        cameraConfig.bounds = nextCamera.bounds;\n      } else {\n        cameraConfig.centerCoordinate = nextCamera.centerCoordinate;\n      }\n\n      this._setCamera(cameraConfig);\n    }\n  }, {\n    key: \"_hasCameraChanged\",\n    value: function _hasCameraChanged(currentCamera, nextCamera) {\n      var c = currentCamera;\n      var n = nextCamera;\n      var hasDefaultPropsChanged = c.heading !== n.heading || this._hasCenterCoordinateChanged(c, n) || this._hasBoundsChanged(c, n) || c.pitch !== n.pitch || c.zoomLevel !== n.zoomLevel || c.triggerKey !== n.triggerKey;\n      var hasFollowPropsChanged = c.followUserLocation !== n.followUserLocation || c.followUserMode !== n.followUserMode || c.followZoomLevel !== n.followZoomLevel || c.followHeading !== n.followHeading || c.followPitch !== n.followPitch;\n      var hasAnimationPropsChanged = c.animationMode !== n.animationMode || c.animationDuration !== n.animationDuration;\n      return hasDefaultPropsChanged || hasFollowPropsChanged || hasAnimationPropsChanged;\n    }\n  }, {\n    key: \"_hasCenterCoordinateChanged\",\n    value: function _hasCenterCoordinateChanged(currentCamera, nextCamera) {\n      var cC = currentCamera.centerCoordinate;\n      var nC = nextCamera.centerCoordinate;\n\n      if (existenceChange(cC, nC)) {\n        return true;\n      }\n\n      if (!cC && !nC) {\n        return false;\n      }\n\n      var isLngDiff = currentCamera.centerCoordinate[0] !== nextCamera.centerCoordinate[0];\n      var isLatDiff = currentCamera.centerCoordinate[1] !== nextCamera.centerCoordinate[1];\n      return isLngDiff || isLatDiff;\n    }\n  }, {\n    key: \"_hasBoundsChanged\",\n    value: function _hasBoundsChanged(currentCamera, nextCamera) {\n      var cB = currentCamera.bounds;\n      var nB = nextCamera.bounds;\n\n      if (!cB && !nB) {\n        return false;\n      }\n\n      if (existenceChange(cB, nB)) {\n        return true;\n      }\n\n      return cB.ne[0] !== nB.ne[0] || cB.ne[1] !== nB.ne[1] || cB.sw[0] !== nB.sw[0] || cB.sw[1] !== nB.sw[1] || cB.paddingTop !== nB.paddingTop || cB.paddingLeft !== nB.paddingLeft || cB.paddingRight !== nB.paddingRight || cB.paddingBottom !== nB.paddingBottom;\n    }\n  }, {\n    key: \"fitBounds\",\n    value: function fitBounds(northEastCoordinates, southWestCoordinates) {\n      var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var animationDuration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.0;\n      var pad = {\n        paddingLeft: 0,\n        paddingRight: 0,\n        paddingTop: 0,\n        paddingBottom: 0\n      };\n\n      if (Array.isArray(padding)) {\n        if (padding.length === 2) {\n          pad.paddingTop = padding[0];\n          pad.paddingBottom = padding[0];\n          pad.paddingLeft = padding[1];\n          pad.paddingRight = padding[1];\n        } else if (padding.length === 4) {\n          pad.paddingTop = padding[0];\n          pad.paddingRight = padding[1];\n          pad.paddingBottom = padding[2];\n          pad.paddingLeft = padding[3];\n        }\n      } else {\n        pad.paddingLeft = padding;\n        pad.paddingRight = padding;\n        pad.paddingTop = padding;\n        pad.paddingBottom = padding;\n      }\n\n      return this.setCamera({\n        bounds: _objectSpread({\n          ne: northEastCoordinates,\n          sw: southWestCoordinates\n        }, pad),\n        animationDuration: animationDuration,\n        animationMode: Camera.Mode.Ease\n      });\n    }\n  }, {\n    key: \"flyTo\",\n    value: function flyTo(coordinates) {\n      var animationDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;\n      return this.setCamera({\n        centerCoordinate: coordinates,\n        animationDuration: animationDuration,\n        animationMode: Camera.Mode.Flight\n      });\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(coordinates) {\n      var animationDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._setCamera({\n        centerCoordinate: coordinates,\n        animationDuration: animationDuration\n      });\n    }\n  }, {\n    key: \"zoomTo\",\n    value: function zoomTo(zoomLevel) {\n      var animationDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;\n      return this._setCamera({\n        zoomLevel: zoomLevel,\n        animationDuration: animationDuration,\n        animationMode: Camera.Mode.Flight\n      });\n    }\n  }, {\n    key: \"setCamera\",\n    value: function setCamera() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._setCamera(config);\n    }\n  }, {\n    key: \"_setCamera\",\n    value: function _setCamera() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var cameraConfig = {};\n\n      if (config.stops) {\n        cameraConfig.stops = [];\n\n        for (var _iterator = _createForOfIteratorHelperLoose(config.stops), _step; !(_step = _iterator()).done;) {\n          var stop = _step.value;\n          cameraConfig.stops.push(this._createStopConfig(stop));\n        }\n      } else {\n        cameraConfig = this._createStopConfig(config);\n      }\n\n      this.refs.camera.setNativeProps({\n        stop: cameraConfig\n      });\n    }\n  }, {\n    key: \"_createDefaultCamera\",\n    value: function _createDefaultCamera() {\n      if (this.defaultCamera) {\n        return this.defaultCamera;\n      }\n\n      if (!this.props.defaultSettings) {\n        return null;\n      }\n\n      this.defaultCamera = this._createStopConfig(_objectSpread(_objectSpread({}, this.props.defaultSettings), {}, {\n        animationMode: Camera.Mode.Move\n      }), true);\n      return this.defaultCamera;\n    }\n  }, {\n    key: \"_createStopConfig\",\n    value: function _createStopConfig() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var ignoreFollowUserLocation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.props.followUserLocation && !ignoreFollowUserLocation) {\n        return null;\n      }\n\n      var stopConfig = {\n        mode: this._getNativeCameraMode(config),\n        pitch: config.pitch,\n        heading: config.heading,\n        duration: config.animationDuration || 0,\n        zoom: config.zoomLevel\n      };\n\n      if (config.centerCoordinate) {\n        stopConfig.centerCoordinate = toJSONString(geoUtils.makePoint(config.centerCoordinate));\n      }\n\n      if (config.bounds && config.bounds.ne && config.bounds.sw) {\n        var _config$bounds = config.bounds,\n            ne = _config$bounds.ne,\n            sw = _config$bounds.sw,\n            paddingLeft = _config$bounds.paddingLeft,\n            paddingRight = _config$bounds.paddingRight,\n            paddingTop = _config$bounds.paddingTop,\n            paddingBottom = _config$bounds.paddingBottom;\n        stopConfig.bounds = toJSONString(geoUtils.makeLatLngBounds(ne, sw));\n        stopConfig.boundsPaddingTop = paddingTop || 0;\n        stopConfig.boundsPaddingRight = paddingRight || 0;\n        stopConfig.boundsPaddingBottom = paddingBottom || 0;\n        stopConfig.boundsPaddingLeft = paddingLeft || 0;\n      }\n\n      return stopConfig;\n    }\n  }, {\n    key: \"_getNativeCameraMode\",\n    value: function _getNativeCameraMode(config) {\n      switch (config.animationMode) {\n        case Camera.Mode.Flight:\n          return MapboxGL.CameraModes.Flight;\n\n        case Camera.Mode.Move:\n          return MapboxGL.CameraModes.None;\n\n        case Camera.Mode.Linear:\n          return MapboxGL.CameraModes.Linear;\n\n        default:\n          return MapboxGL.CameraModes.Ease;\n      }\n    }\n  }, {\n    key: \"_getMaxBounds\",\n    value: function _getMaxBounds() {\n      var bounds = this.props.maxBounds;\n\n      if (!bounds || !bounds.ne || !bounds.sw) {\n        return null;\n      }\n\n      return toJSONString(geoUtils.makeLatLngBounds(bounds.ne, bounds.sw));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var props = _extends({}, this.props);\n\n      var callbacks = {\n        onUserTrackingModeChange: props.onUserTrackingModeChange\n      };\n      return React.createElement(RCTMGLCamera, _extends({\n        testID: \"Camera\",\n        ref: \"camera\",\n        followUserLocation: this.props.followUserLocation,\n        followUserMode: this.props.followUserMode,\n        followPitch: this.props.followPitch,\n        followHeading: this.props.followHeading,\n        followZoomLevel: this.props.followZoomLevel,\n        stop: this._createStopConfig(props),\n        maxZoomLevel: this.props.maxZoomLevel,\n        minZoomLevel: this.props.minZoomLevel,\n        maxBounds: this._getMaxBounds(),\n        defaultStop: this._createDefaultCamera()\n      }, callbacks, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 524,\n          columnNumber: 7\n        }\n      }));\n    }\n  }]);\n\n  return Camera;\n}(React.Component);\n\nCamera.propTypes = _objectSpread(_objectSpread(_objectSpread({}, viewPropTypes), {}, {\n  animationDuration: PropTypes.number,\n  animationMode: PropTypes.oneOf(['flyTo', 'easeTo', 'linearTo', 'moveTo']),\n  defaultSettings: PropTypes.shape(SettingsPropTypes)\n}, SettingsPropTypes), {}, {\n  minZoomLevel: PropTypes.number,\n  maxZoomLevel: PropTypes.number,\n  maxBounds: PropTypes.shape({\n    ne: PropTypes.arrayOf(PropTypes.number).isRequired,\n    sw: PropTypes.arrayOf(PropTypes.number).isRequired\n  }),\n  followUserLocation: PropTypes.bool,\n  followUserMode: PropTypes.oneOf(['normal', 'compass', 'course']),\n  followZoomLevel: PropTypes.number,\n  followPitch: PropTypes.number,\n  followHeading: PropTypes.number,\n  triggerKey: PropTypes.any,\n  onUserTrackingModeChange: PropTypes.func\n});\nCamera.defaultProps = {\n  animationMode: 'easeTo',\n  animationDuration: 2000\n};\nCamera.Mode = {\n  Flight: 'flyTo',\n  Move: 'moveTo',\n  Ease: 'easeTo',\n  Linear: 'linearTo'\n};\nvar RCTMGLCamera = requireNativeComponent(NATIVE_MODULE_NAME, Camera, {\n  nativeOnly: {\n    stop: true\n  }\n});\nCamera.UserTrackingModes = {\n  Follow: 'normal',\n  FollowWithHeading: 'compass',\n  FollowWithCourse: 'course'\n};\nexport default Camera;","map":{"version":3,"sources":["/Users/asha/Documents/miniboss/node_modules/@react-native-mapbox-gl/maps/javascript/components/Camera.js"],"names":["React","PropTypes","requireNativeComponent","toJSONString","viewPropTypes","existenceChange","geoUtils","MapboxGL","NativeModules","MGLModule","NATIVE_MODULE_NAME","SettingsPropTypes","centerCoordinate","arrayOf","number","heading","pitch","bounds","shape","ne","isRequired","sw","paddingLeft","paddingRight","paddingTop","paddingBottom","onUserTrackingModeChange","func","zoomLevel","Camera","nextProps","_handleCameraChange","props","currentCamera","nextCamera","hasCameraChanged","_hasCameraChanged","followUserLocation","refs","camera","setNativeProps","followUserMode","followPitch","followHeading","followZoomLevel","cameraConfig","animationMode","animationDuration","_hasBoundsChanged","_setCamera","c","n","hasDefaultPropsChanged","_hasCenterCoordinateChanged","triggerKey","hasFollowPropsChanged","hasAnimationPropsChanged","cC","nC","isLngDiff","isLatDiff","cB","nB","northEastCoordinates","southWestCoordinates","padding","pad","Array","isArray","length","setCamera","Mode","Ease","coordinates","Flight","config","stops","stop","push","_createStopConfig","defaultCamera","defaultSettings","Move","ignoreFollowUserLocation","stopConfig","mode","_getNativeCameraMode","duration","zoom","makePoint","makeLatLngBounds","boundsPaddingTop","boundsPaddingRight","boundsPaddingBottom","boundsPaddingLeft","CameraModes","None","Linear","maxBounds","callbacks","maxZoomLevel","minZoomLevel","_getMaxBounds","_createDefaultCamera","Component","propTypes","oneOf","bool","any","defaultProps","RCTMGLCamera","nativeOnly","UserTrackingModes","Follow","FollowWithHeading","FollowWithCourse"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,SAAP,MAAsB,YAAtB;;SACuBC,sB;AAEvB,SAAQC,YAAR,EAAsBC,aAAtB,EAAqCC,eAArC;AACA,OAAO,KAAKC,QAAZ;AAEA,IAAMC,QAAQ,GAAGC,aAAa,CAACC,SAA/B;AAEA,OAAO,IAAMC,kBAAkB,GAAG,cAA3B;AAEP,IAAMC,iBAAiB,GAAG;AAIxBC,EAAAA,gBAAgB,EAAEX,SAAS,CAACY,OAAV,CAAkBZ,SAAS,CAACa,MAA5B,CAJM;AASxBC,EAAAA,OAAO,EAAEd,SAAS,CAACa,MATK;AAcxBE,EAAAA,KAAK,EAAEf,SAAS,CAACa,MAdO;AAmBxBG,EAAAA,MAAM,EAAEhB,SAAS,CAACiB,KAAV,CAAgB;AAItBC,IAAAA,EAAE,EAAElB,SAAS,CAACY,OAAV,CAAkBZ,SAAS,CAACa,MAA5B,EAAoCM,UAJlB;AAStBC,IAAAA,EAAE,EAAEpB,SAAS,CAACY,OAAV,CAAkBZ,SAAS,CAACa,MAA5B,EAAoCM,UATlB;AActBE,IAAAA,WAAW,EAAErB,SAAS,CAACa,MAdD;AAmBtBS,IAAAA,YAAY,EAAEtB,SAAS,CAACa,MAnBF;AAwBtBU,IAAAA,UAAU,EAAEvB,SAAS,CAACa,MAxBA;AA6BtBW,IAAAA,aAAa,EAAExB,SAAS,CAACa,MA7BH;AAkCtBY,IAAAA,wBAAwB,EAAEzB,SAAS,CAAC0B;AAlCd,GAAhB,CAnBgB;AA2DxBC,EAAAA,SAAS,EAAE3B,SAAS,CAACa;AA3DG,CAA1B;;IA8DMe,M;;;;;;;;;;;;;WA6FJ,0CAAiCC,SAAjC,EAA4C;AAC1C,WAAKC,mBAAL,CAAyB,KAAKC,KAA9B,EAAqCF,SAArC;AACD;;;WAED,iCAAwB;AACtB,aAAO,KAAP;AACD;;;WAED,6BAAoBG,aAApB,EAAmCC,UAAnC,EAA+C;AAC7C,UAAMC,gBAAgB,GAAG,KAAKC,iBAAL,CAAuBH,aAAvB,EAAsCC,UAAtC,CAAzB;;AACA,UAAI,CAACC,gBAAL,EAAuB;AACrB;AACD;;AAED,UAAIF,aAAa,CAACI,kBAAd,IAAoC,CAACH,UAAU,CAACG,kBAApD,EAAwE;AACtE,aAAKC,IAAL,CAAUC,MAAV,CAAiBC,cAAjB,CAAgC;AAACH,UAAAA,kBAAkB,EAAE;AAArB,SAAhC;AACA;AACD;;AACD,UAAI,CAACJ,aAAa,CAACI,kBAAf,IAAqCH,UAAU,CAACG,kBAApD,EAAwE;AACtE,aAAKC,IAAL,CAAUC,MAAV,CAAiBC,cAAjB,CAAgC;AAACH,UAAAA,kBAAkB,EAAE;AAArB,SAAhC;AACD;;AAED,UAAIH,UAAU,CAACG,kBAAf,EAAmC;AACjC,aAAKC,IAAL,CAAUC,MAAV,CAAiBC,cAAjB,CAAgC;AAC9BC,UAAAA,cAAc,EAAEP,UAAU,CAACO,cADG;AAE9BC,UAAAA,WAAW,EAAER,UAAU,CAACQ,WAAX,IAA0BR,UAAU,CAAClB,KAFpB;AAG9B2B,UAAAA,aAAa,EAAET,UAAU,CAACS,aAAX,IAA4BT,UAAU,CAACnB,OAHxB;AAI9B6B,UAAAA,eAAe,EAAEV,UAAU,CAACU,eAAX,IAA8BV,UAAU,CAACN;AAJ5B,SAAhC;AAMA;AACD;;AAED,UAAMiB,YAAY,GAAG;AACnBC,QAAAA,aAAa,EAAEZ,UAAU,CAACY,aADP;AAEnBC,QAAAA,iBAAiB,EAAEb,UAAU,CAACa,iBAFX;AAGnBnB,QAAAA,SAAS,EAAEM,UAAU,CAACN,SAHH;AAInBZ,QAAAA,KAAK,EAAEkB,UAAU,CAAClB,KAJC;AAKnBD,QAAAA,OAAO,EAAEmB,UAAU,CAACnB;AALD,OAArB;;AAQA,UACEmB,UAAU,CAACjB,MAAX,IACA,KAAK+B,iBAAL,CAAuBf,aAAvB,EAAsCC,UAAtC,CAFF,EAGE;AACAW,QAAAA,YAAY,CAAC5B,MAAb,GAAsBiB,UAAU,CAACjB,MAAjC;AACD,OALD,MAKO;AACL4B,QAAAA,YAAY,CAACjC,gBAAb,GAAgCsB,UAAU,CAACtB,gBAA3C;AACD;;AAED,WAAKqC,UAAL,CAAgBJ,YAAhB;AACD;;;WAED,2BAAkBZ,aAAlB,EAAiCC,UAAjC,EAA6C;AAC3C,UAAMgB,CAAC,GAAGjB,aAAV;AACA,UAAMkB,CAAC,GAAGjB,UAAV;AAEA,UAAMkB,sBAAsB,GAC1BF,CAAC,CAACnC,OAAF,KAAcoC,CAAC,CAACpC,OAAhB,IACA,KAAKsC,2BAAL,CAAiCH,CAAjC,EAAoCC,CAApC,CADA,IAEA,KAAKH,iBAAL,CAAuBE,CAAvB,EAA0BC,CAA1B,CAFA,IAGAD,CAAC,CAAClC,KAAF,KAAYmC,CAAC,CAACnC,KAHd,IAIAkC,CAAC,CAACtB,SAAF,KAAgBuB,CAAC,CAACvB,SAJlB,IAKAsB,CAAC,CAACI,UAAF,KAAiBH,CAAC,CAACG,UANrB;AAQA,UAAMC,qBAAqB,GACzBL,CAAC,CAACb,kBAAF,KAAyBc,CAAC,CAACd,kBAA3B,IACAa,CAAC,CAACT,cAAF,KAAqBU,CAAC,CAACV,cADvB,IAEAS,CAAC,CAACN,eAAF,KAAsBO,CAAC,CAACP,eAFxB,IAGAM,CAAC,CAACP,aAAF,KAAoBQ,CAAC,CAACR,aAHtB,IAIAO,CAAC,CAACR,WAAF,KAAkBS,CAAC,CAACT,WALtB;AAOA,UAAMc,wBAAwB,GAC5BN,CAAC,CAACJ,aAAF,KAAoBK,CAAC,CAACL,aAAtB,IACAI,CAAC,CAACH,iBAAF,KAAwBI,CAAC,CAACJ,iBAF5B;AAIA,aACEK,sBAAsB,IACtBG,qBADA,IAEAC,wBAHF;AAKD;;;WAED,qCAA4BvB,aAA5B,EAA2CC,UAA3C,EAAuD;AACrD,UAAMuB,EAAE,GAAGxB,aAAa,CAACrB,gBAAzB;AACA,UAAM8C,EAAE,GAAGxB,UAAU,CAACtB,gBAAtB;;AAEA,UAAIP,eAAe,CAACoD,EAAD,EAAKC,EAAL,CAAnB,EAA6B;AAC3B,eAAO,IAAP;AACD;;AAED,UAAI,CAACD,EAAD,IAAO,CAACC,EAAZ,EAAgB;AACd,eAAO,KAAP;AACD;;AAED,UAAMC,SAAS,GACb1B,aAAa,CAACrB,gBAAd,CAA+B,CAA/B,MAAsCsB,UAAU,CAACtB,gBAAX,CAA4B,CAA5B,CADxC;AAEA,UAAMgD,SAAS,GACb3B,aAAa,CAACrB,gBAAd,CAA+B,CAA/B,MAAsCsB,UAAU,CAACtB,gBAAX,CAA4B,CAA5B,CADxC;AAEA,aAAO+C,SAAS,IAAIC,SAApB;AACD;;;WAED,2BAAkB3B,aAAlB,EAAiCC,UAAjC,EAA6C;AAC3C,UAAM2B,EAAE,GAAG5B,aAAa,CAAChB,MAAzB;AACA,UAAM6C,EAAE,GAAG5B,UAAU,CAACjB,MAAtB;;AAEA,UAAI,CAAC4C,EAAD,IAAO,CAACC,EAAZ,EAAgB;AACd,eAAO,KAAP;AACD;;AAED,UAAIzD,eAAe,CAACwD,EAAD,EAAKC,EAAL,CAAnB,EAA6B;AAC3B,eAAO,IAAP;AACD;;AAED,aACED,EAAE,CAAC1C,EAAH,CAAM,CAAN,MAAa2C,EAAE,CAAC3C,EAAH,CAAM,CAAN,CAAb,IACA0C,EAAE,CAAC1C,EAAH,CAAM,CAAN,MAAa2C,EAAE,CAAC3C,EAAH,CAAM,CAAN,CADb,IAEA0C,EAAE,CAACxC,EAAH,CAAM,CAAN,MAAayC,EAAE,CAACzC,EAAH,CAAM,CAAN,CAFb,IAGAwC,EAAE,CAACxC,EAAH,CAAM,CAAN,MAAayC,EAAE,CAACzC,EAAH,CAAM,CAAN,CAHb,IAIAwC,EAAE,CAACrC,UAAH,KAAkBsC,EAAE,CAACtC,UAJrB,IAKAqC,EAAE,CAACvC,WAAH,KAAmBwC,EAAE,CAACxC,WALtB,IAMAuC,EAAE,CAACtC,YAAH,KAAoBuC,EAAE,CAACvC,YANvB,IAOAsC,EAAE,CAACpC,aAAH,KAAqBqC,EAAE,CAACrC,aAR1B;AAUD;;;WAiBD,mBACEsC,oBADF,EAEEC,oBAFF,EAKE;AAAA,UAFAC,OAEA,uEAFU,CAEV;AAAA,UADAlB,iBACA,uEADoB,GACpB;AACA,UAAMmB,GAAG,GAAG;AACV5C,QAAAA,WAAW,EAAE,CADH;AAEVC,QAAAA,YAAY,EAAE,CAFJ;AAGVC,QAAAA,UAAU,EAAE,CAHF;AAIVC,QAAAA,aAAa,EAAE;AAJL,OAAZ;;AAOA,UAAI0C,KAAK,CAACC,OAAN,CAAcH,OAAd,CAAJ,EAA4B;AAC1B,YAAIA,OAAO,CAACI,MAAR,KAAmB,CAAvB,EAA0B;AACxBH,UAAAA,GAAG,CAAC1C,UAAJ,GAAiByC,OAAO,CAAC,CAAD,CAAxB;AACAC,UAAAA,GAAG,CAACzC,aAAJ,GAAoBwC,OAAO,CAAC,CAAD,CAA3B;AACAC,UAAAA,GAAG,CAAC5C,WAAJ,GAAkB2C,OAAO,CAAC,CAAD,CAAzB;AACAC,UAAAA,GAAG,CAAC3C,YAAJ,GAAmB0C,OAAO,CAAC,CAAD,CAA1B;AACD,SALD,MAKO,IAAIA,OAAO,CAACI,MAAR,KAAmB,CAAvB,EAA0B;AAC/BH,UAAAA,GAAG,CAAC1C,UAAJ,GAAiByC,OAAO,CAAC,CAAD,CAAxB;AACAC,UAAAA,GAAG,CAAC3C,YAAJ,GAAmB0C,OAAO,CAAC,CAAD,CAA1B;AACAC,UAAAA,GAAG,CAACzC,aAAJ,GAAoBwC,OAAO,CAAC,CAAD,CAA3B;AACAC,UAAAA,GAAG,CAAC5C,WAAJ,GAAkB2C,OAAO,CAAC,CAAD,CAAzB;AACD;AACF,OAZD,MAYO;AACLC,QAAAA,GAAG,CAAC5C,WAAJ,GAAkB2C,OAAlB;AACAC,QAAAA,GAAG,CAAC3C,YAAJ,GAAmB0C,OAAnB;AACAC,QAAAA,GAAG,CAAC1C,UAAJ,GAAiByC,OAAjB;AACAC,QAAAA,GAAG,CAACzC,aAAJ,GAAoBwC,OAApB;AACD;;AAED,aAAO,KAAKK,SAAL,CAAe;AACpBrD,QAAAA,MAAM;AACJE,UAAAA,EAAE,EAAE4C,oBADA;AAEJ1C,UAAAA,EAAE,EAAE2C;AAFA,WAGDE,GAHC,CADc;AAMpBnB,QAAAA,iBAAiB,EAAjBA,iBANoB;AAOpBD,QAAAA,aAAa,EAAEjB,MAAM,CAAC0C,IAAP,CAAYC;AAPP,OAAf,CAAP;AASD;;;WAaD,eAAMC,WAAN,EAA6C;AAAA,UAA1B1B,iBAA0B,uEAAN,IAAM;AAC3C,aAAO,KAAKuB,SAAL,CAAe;AACpB1D,QAAAA,gBAAgB,EAAE6D,WADE;AAEpB1B,QAAAA,iBAAiB,EAAjBA,iBAFoB;AAGpBD,QAAAA,aAAa,EAAEjB,MAAM,CAAC0C,IAAP,CAAYG;AAHP,OAAf,CAAP;AAKD;;;WAaD,gBAAOD,WAAP,EAA2C;AAAA,UAAvB1B,iBAAuB,uEAAH,CAAG;AACzC,aAAO,KAAKE,UAAL,CAAgB;AACrBrC,QAAAA,gBAAgB,EAAE6D,WADG;AAErB1B,QAAAA,iBAAiB,EAAjBA;AAFqB,OAAhB,CAAP;AAID;;;WAaD,gBAAOnB,SAAP,EAA4C;AAAA,UAA1BmB,iBAA0B,uEAAN,IAAM;AAC1C,aAAO,KAAKE,UAAL,CAAgB;AACrBrB,QAAAA,SAAS,EAATA,SADqB;AAErBmB,QAAAA,iBAAiB,EAAjBA,iBAFqB;AAGrBD,QAAAA,aAAa,EAAEjB,MAAM,CAAC0C,IAAP,CAAYG;AAHN,OAAhB,CAAP;AAKD;;;WAqBD,qBAAuB;AAAA,UAAbC,MAAa,uEAAJ,EAAI;;AACrB,WAAK1B,UAAL,CAAgB0B,MAAhB;AACD;;;WAED,sBAAwB;AAAA,UAAbA,MAAa,uEAAJ,EAAI;AACtB,UAAI9B,YAAY,GAAG,EAAnB;;AAEA,UAAI8B,MAAM,CAACC,KAAX,EAAkB;AAChB/B,QAAAA,YAAY,CAAC+B,KAAb,GAAqB,EAArB;;AAEA,6DAAmBD,MAAM,CAACC,KAA1B,wCAAiC;AAAA,cAAtBC,IAAsB;AAC/BhC,UAAAA,YAAY,CAAC+B,KAAb,CAAmBE,IAAnB,CAAwB,KAAKC,iBAAL,CAAuBF,IAAvB,CAAxB;AACD;AACF,OAND,MAMO;AACLhC,QAAAA,YAAY,GAAG,KAAKkC,iBAAL,CAAuBJ,MAAvB,CAAf;AACD;;AAED,WAAKrC,IAAL,CAAUC,MAAV,CAAiBC,cAAjB,CAAgC;AAACqC,QAAAA,IAAI,EAAEhC;AAAP,OAAhC;AACD;;;WAED,gCAAuB;AACrB,UAAI,KAAKmC,aAAT,EAAwB;AACtB,eAAO,KAAKA,aAAZ;AACD;;AACD,UAAI,CAAC,KAAKhD,KAAL,CAAWiD,eAAhB,EAAiC;AAC/B,eAAO,IAAP;AACD;;AAED,WAAKD,aAAL,GAAqB,KAAKD,iBAAL,iCAEd,KAAK/C,KAAL,CAAWiD,eAFG;AAGjBnC,QAAAA,aAAa,EAAEjB,MAAM,CAAC0C,IAAP,CAAYW;AAHV,UAKnB,IALmB,CAArB;AAOA,aAAO,KAAKF,aAAZ;AACD;;;WAED,6BAAiE;AAAA,UAA/CL,MAA+C,uEAAtC,EAAsC;AAAA,UAAlCQ,wBAAkC,uEAAP,KAAO;;AAC/D,UAAI,KAAKnD,KAAL,CAAWK,kBAAX,IAAiC,CAAC8C,wBAAtC,EAAgE;AAC9D,eAAO,IAAP;AACD;;AAED,UAAMC,UAAU,GAAG;AACjBC,QAAAA,IAAI,EAAE,KAAKC,oBAAL,CAA0BX,MAA1B,CADW;AAEjB3D,QAAAA,KAAK,EAAE2D,MAAM,CAAC3D,KAFG;AAGjBD,QAAAA,OAAO,EAAE4D,MAAM,CAAC5D,OAHC;AAIjBwE,QAAAA,QAAQ,EAAEZ,MAAM,CAAC5B,iBAAP,IAA4B,CAJrB;AAKjByC,QAAAA,IAAI,EAAEb,MAAM,CAAC/C;AALI,OAAnB;;AAQA,UAAI+C,MAAM,CAAC/D,gBAAX,EAA6B;AAC3BwE,QAAAA,UAAU,CAACxE,gBAAX,GAA8BT,YAAY,CACxCG,QAAQ,CAACmF,SAAT,CAAmBd,MAAM,CAAC/D,gBAA1B,CADwC,CAA1C;AAGD;;AAED,UAAI+D,MAAM,CAAC1D,MAAP,IAAiB0D,MAAM,CAAC1D,MAAP,CAAcE,EAA/B,IAAqCwD,MAAM,CAAC1D,MAAP,CAAcI,EAAvD,EAA2D;AACzD,6BACEsD,MAAM,CAAC1D,MADT;AAAA,YAAOE,EAAP,kBAAOA,EAAP;AAAA,YAAWE,EAAX,kBAAWA,EAAX;AAAA,YAAeC,WAAf,kBAAeA,WAAf;AAAA,YAA4BC,YAA5B,kBAA4BA,YAA5B;AAAA,YAA0CC,UAA1C,kBAA0CA,UAA1C;AAAA,YAAsDC,aAAtD,kBAAsDA,aAAtD;AAEA2D,QAAAA,UAAU,CAACnE,MAAX,GAAoBd,YAAY,CAACG,QAAQ,CAACoF,gBAAT,CAA0BvE,EAA1B,EAA8BE,EAA9B,CAAD,CAAhC;AACA+D,QAAAA,UAAU,CAACO,gBAAX,GAA8BnE,UAAU,IAAI,CAA5C;AACA4D,QAAAA,UAAU,CAACQ,kBAAX,GAAgCrE,YAAY,IAAI,CAAhD;AACA6D,QAAAA,UAAU,CAACS,mBAAX,GAAiCpE,aAAa,IAAI,CAAlD;AACA2D,QAAAA,UAAU,CAACU,iBAAX,GAA+BxE,WAAW,IAAI,CAA9C;AACD;;AAED,aAAO8D,UAAP;AACD;;;WAED,8BAAqBT,MAArB,EAA6B;AAC3B,cAAQA,MAAM,CAAC7B,aAAf;AACE,aAAKjB,MAAM,CAAC0C,IAAP,CAAYG,MAAjB;AACE,iBAAOnE,QAAQ,CAACwF,WAAT,CAAqBrB,MAA5B;;AACF,aAAK7C,MAAM,CAAC0C,IAAP,CAAYW,IAAjB;AACE,iBAAO3E,QAAQ,CAACwF,WAAT,CAAqBC,IAA5B;;AACF,aAAKnE,MAAM,CAAC0C,IAAP,CAAY0B,MAAjB;AACE,iBAAO1F,QAAQ,CAACwF,WAAT,CAAqBE,MAA5B;;AACF;AACE,iBAAO1F,QAAQ,CAACwF,WAAT,CAAqBvB,IAA5B;AARJ;AAUD;;;WAED,yBAAgB;AACd,UAAMvD,MAAM,GAAG,KAAKe,KAAL,CAAWkE,SAA1B;;AACA,UAAI,CAACjF,MAAD,IAAW,CAACA,MAAM,CAACE,EAAnB,IAAyB,CAACF,MAAM,CAACI,EAArC,EAAyC;AACvC,eAAO,IAAP;AACD;;AACD,aAAOlB,YAAY,CAACG,QAAQ,CAACoF,gBAAT,CAA0BzE,MAAM,CAACE,EAAjC,EAAqCF,MAAM,CAACI,EAA5C,CAAD,CAAnB;AACD;;;WAED,kBAAS;AACP,UAAMW,KAAK,GAAG,SAAc,EAAd,EAAkB,KAAKA,KAAvB,CAAd;;AAEA,UAAMmE,SAAS,GAAG;AAChBzE,QAAAA,wBAAwB,EAAEM,KAAK,CAACN;AADhB,OAAlB;AAIA,aACE,oBAAC,YAAD;AACE,QAAA,MAAM,EAAC,QADT;AAEE,QAAA,GAAG,EAAC,QAFN;AAGE,QAAA,kBAAkB,EAAE,KAAKM,KAAL,CAAWK,kBAHjC;AAIE,QAAA,cAAc,EAAE,KAAKL,KAAL,CAAWS,cAJ7B;AAKE,QAAA,WAAW,EAAE,KAAKT,KAAL,CAAWU,WAL1B;AAME,QAAA,aAAa,EAAE,KAAKV,KAAL,CAAWW,aAN5B;AAOE,QAAA,eAAe,EAAE,KAAKX,KAAL,CAAWY,eAP9B;AAQE,QAAA,IAAI,EAAE,KAAKmC,iBAAL,CAAuB/C,KAAvB,CARR;AASE,QAAA,YAAY,EAAE,KAAKA,KAAL,CAAWoE,YAT3B;AAUE,QAAA,YAAY,EAAE,KAAKpE,KAAL,CAAWqE,YAV3B;AAWE,QAAA,SAAS,EAAE,KAAKC,aAAL,EAXb;AAYE,QAAA,WAAW,EAAE,KAAKC,oBAAL;AAZf,SAaMJ,SAbN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SADF;AAiBD;;;;EAldkBnG,KAAK,CAACwG,S;;AAArB3E,M,CACG4E,S,iDACFrG,a;AAKH2C,EAAAA,iBAAiB,EAAE9C,SAAS,CAACa,M;AAK7BgC,EAAAA,aAAa,EAAE7C,SAAS,CAACyG,KAAV,CAAgB,CAAC,OAAD,EAAU,QAAV,EAAoB,UAApB,EAAgC,QAAhC,CAAhB,C;AAKfzB,EAAAA,eAAe,EAAEhF,SAAS,CAACiB,KAAV,CAAgBP,iBAAhB;GAGdA,iB;AAKH0F,EAAAA,YAAY,EAAEpG,SAAS,CAACa,M;AAKxBsF,EAAAA,YAAY,EAAEnG,SAAS,CAACa,M;AAKxBoF,EAAAA,SAAS,EAAEjG,SAAS,CAACiB,KAAV,CAAgB;AAIzBC,IAAAA,EAAE,EAAElB,SAAS,CAACY,OAAV,CAAkBZ,SAAS,CAACa,MAA5B,EAAoCM,UAJf;AASzBC,IAAAA,EAAE,EAAEpB,SAAS,CAACY,OAAV,CAAkBZ,SAAS,CAACa,MAA5B,EAAoCM;AATf,GAAhB,C;AAeXiB,EAAAA,kBAAkB,EAAEpC,SAAS,CAAC0G,I;AAK9BlE,EAAAA,cAAc,EAAExC,SAAS,CAACyG,KAAV,CAAgB,CAAC,QAAD,EAAW,SAAX,EAAsB,QAAtB,CAAhB,C;AAKhB9D,EAAAA,eAAe,EAAE3C,SAAS,CAACa,M;AAK3B4B,EAAAA,WAAW,EAAEzC,SAAS,CAACa,M;AAKvB6B,EAAAA,aAAa,EAAE1C,SAAS,CAACa,M;AAKzBwC,EAAAA,UAAU,EAAErD,SAAS,CAAC2G,G;AAGtBlF,EAAAA,wBAAwB,EAAEzB,SAAS,CAAC0B;;AA9ElCE,M,CAiFGgF,Y,GAAe;AACpB/D,EAAAA,aAAa,EAAE,QADK;AAEpBC,EAAAA,iBAAiB,EAAE;AAFC,C;AAjFlBlB,M,CAsFG0C,I,GAAO;AACZG,EAAAA,MAAM,EAAE,OADI;AAEZQ,EAAAA,IAAI,EAAE,QAFM;AAGZV,EAAAA,IAAI,EAAE,QAHM;AAIZyB,EAAAA,MAAM,EAAE;AAJI,C;AA+XhB,IAAMa,YAAY,GAAG5G,sBAAsB,CAACQ,kBAAD,EAAqBmB,MAArB,EAA6B;AACtEkF,EAAAA,UAAU,EAAE;AACVlC,IAAAA,IAAI,EAAE;AADI;AAD0D,CAA7B,CAA3C;AAMAhD,MAAM,CAACmF,iBAAP,GAA2B;AACzBC,EAAAA,MAAM,EAAE,QADiB;AAEzBC,EAAAA,iBAAiB,EAAE,SAFM;AAGzBC,EAAAA,gBAAgB,EAAE;AAHO,CAA3B;AAMA,eAAetF,MAAf","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport {NativeModules, requireNativeComponent} from 'react-native';\n\nimport {toJSONString, viewPropTypes, existenceChange} from '../utils';\nimport * as geoUtils from '../utils/geoUtils';\n\nconst MapboxGL = NativeModules.MGLModule;\n\nexport const NATIVE_MODULE_NAME = 'RCTMGLCamera';\n\nconst SettingsPropTypes = {\n  /**\n   * Center coordinate on map [lng, lat]\n   */\n  centerCoordinate: PropTypes.arrayOf(PropTypes.number),\n\n  /**\n   * Heading on map\n   */\n  heading: PropTypes.number,\n\n  /**\n   * Pitch on map\n   */\n  pitch: PropTypes.number,\n\n  /**\n   * Represents a rectangle in geographical coordinates marking the visible area of the map.\n   */\n  bounds: PropTypes.shape({\n    /**\n     * North east coordinate of bound\n     */\n    ne: PropTypes.arrayOf(PropTypes.number).isRequired,\n\n    /**\n     * South west coordinate of bound\n     */\n    sw: PropTypes.arrayOf(PropTypes.number).isRequired,\n\n    /**\n     * Left camera padding for bounds\n     */\n    paddingLeft: PropTypes.number,\n\n    /**\n     * Right camera padding for bounds\n     */\n    paddingRight: PropTypes.number,\n\n    /**\n     * Top camera padding for bounds\n     */\n    paddingTop: PropTypes.number,\n\n    /**\n     * Bottom camera padding for bounds\n     */\n    paddingBottom: PropTypes.number,\n\n    /**\n     * Callback that is triggered on user tracking mode changes\n     */\n    onUserTrackingModeChange: PropTypes.func,\n  }),\n\n  /**\n   * Zoom level of the map\n   */\n  zoomLevel: PropTypes.number,\n};\n\nclass Camera extends React.Component {\n  static propTypes = {\n    ...viewPropTypes,\n\n    /**\n     * The duration a camera update takes (in ms)\n     */\n    animationDuration: PropTypes.number,\n\n    /**\n     * The animationstyle when the camara updates. One of; `flyTo`, `easeTo`, `linearTo`, `moveTo`\n     */\n    animationMode: PropTypes.oneOf(['flyTo', 'easeTo', 'linearTo', 'moveTo']),\n\n    /**\n     * Default view settings applied on camera\n     */\n    defaultSettings: PropTypes.shape(SettingsPropTypes),\n\n    // normal - view settings\n    ...SettingsPropTypes,\n\n    /**\n     * The minimun zoom level of the map\n     */\n    minZoomLevel: PropTypes.number,\n\n    /**\n     * The maximun zoom level of the map\n     */\n    maxZoomLevel: PropTypes.number,\n\n    /**\n     * Restrict map panning so that the center is within these bounds\n     */\n    maxBounds: PropTypes.shape({\n      /**\n       * northEastCoordinates - North east coordinate of bound\n       */\n      ne: PropTypes.arrayOf(PropTypes.number).isRequired,\n\n      /**\n       * southWestCoordinates - South west coordinate of bound\n       */\n      sw: PropTypes.arrayOf(PropTypes.number).isRequired,\n    }),\n\n    /**\n     * Should the map orientation follow the user's.\n     */\n    followUserLocation: PropTypes.bool,\n\n    /**\n     * The mode used to track the user location on the map. One of; \"normal\", \"compass\", \"course\". Each mode string is also available as a member on the `MapboxGL.UserTrackingModes` object. `Follow` (normal), `FollowWithHeading` (compass), `FollowWithCourse` (course). NOTE: `followUserLocation` must be set to `true` for any of the modes to take effect. [Example](../example/src/examples/SetUserTrackingModes.js)\n     */\n    followUserMode: PropTypes.oneOf(['normal', 'compass', 'course']),\n\n    /**\n     * The zoomLevel on map while followUserLocation is set to `true`\n     */\n    followZoomLevel: PropTypes.number,\n\n    /**\n     * The pitch on map while followUserLocation is set to `true`\n     */\n    followPitch: PropTypes.number,\n\n    /**\n     * The heading on map while followUserLocation is set to `true`\n     */\n    followHeading: PropTypes.number,\n\n    /**\n     * Manually update the camera - helpful for when props did not update, however you still want the camera to move\n     */\n    triggerKey: PropTypes.any,\n\n    // Triggered when the\n    onUserTrackingModeChange: PropTypes.func,\n  };\n\n  static defaultProps = {\n    animationMode: 'easeTo',\n    animationDuration: 2000,\n  };\n\n  static Mode = {\n    Flight: 'flyTo',\n    Move: 'moveTo',\n    Ease: 'easeTo',\n    Linear: 'linearTo',\n  };\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    this._handleCameraChange(this.props, nextProps);\n  }\n\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  _handleCameraChange(currentCamera, nextCamera) {\n    const hasCameraChanged = this._hasCameraChanged(currentCamera, nextCamera);\n    if (!hasCameraChanged) {\n      return;\n    }\n\n    if (currentCamera.followUserLocation && !nextCamera.followUserLocation) {\n      this.refs.camera.setNativeProps({followUserLocation: false});\n      return;\n    }\n    if (!currentCamera.followUserLocation && nextCamera.followUserLocation) {\n      this.refs.camera.setNativeProps({followUserLocation: true});\n    }\n\n    if (nextCamera.followUserLocation) {\n      this.refs.camera.setNativeProps({\n        followUserMode: nextCamera.followUserMode,\n        followPitch: nextCamera.followPitch || nextCamera.pitch,\n        followHeading: nextCamera.followHeading || nextCamera.heading,\n        followZoomLevel: nextCamera.followZoomLevel || nextCamera.zoomLevel,\n      });\n      return;\n    }\n\n    const cameraConfig = {\n      animationMode: nextCamera.animationMode,\n      animationDuration: nextCamera.animationDuration,\n      zoomLevel: nextCamera.zoomLevel,\n      pitch: nextCamera.pitch,\n      heading: nextCamera.heading,\n    };\n\n    if (\n      nextCamera.bounds &&\n      this._hasBoundsChanged(currentCamera, nextCamera)\n    ) {\n      cameraConfig.bounds = nextCamera.bounds;\n    } else {\n      cameraConfig.centerCoordinate = nextCamera.centerCoordinate;\n    }\n\n    this._setCamera(cameraConfig);\n  }\n\n  _hasCameraChanged(currentCamera, nextCamera) {\n    const c = currentCamera;\n    const n = nextCamera;\n\n    const hasDefaultPropsChanged =\n      c.heading !== n.heading ||\n      this._hasCenterCoordinateChanged(c, n) ||\n      this._hasBoundsChanged(c, n) ||\n      c.pitch !== n.pitch ||\n      c.zoomLevel !== n.zoomLevel ||\n      c.triggerKey !== n.triggerKey;\n\n    const hasFollowPropsChanged =\n      c.followUserLocation !== n.followUserLocation ||\n      c.followUserMode !== n.followUserMode ||\n      c.followZoomLevel !== n.followZoomLevel ||\n      c.followHeading !== n.followHeading ||\n      c.followPitch !== n.followPitch;\n\n    const hasAnimationPropsChanged =\n      c.animationMode !== n.animationMode ||\n      c.animationDuration !== n.animationDuration;\n\n    return (\n      hasDefaultPropsChanged ||\n      hasFollowPropsChanged ||\n      hasAnimationPropsChanged\n    );\n  }\n\n  _hasCenterCoordinateChanged(currentCamera, nextCamera) {\n    const cC = currentCamera.centerCoordinate;\n    const nC = nextCamera.centerCoordinate;\n\n    if (existenceChange(cC, nC)) {\n      return true;\n    }\n\n    if (!cC && !nC) {\n      return false;\n    }\n\n    const isLngDiff =\n      currentCamera.centerCoordinate[0] !== nextCamera.centerCoordinate[0];\n    const isLatDiff =\n      currentCamera.centerCoordinate[1] !== nextCamera.centerCoordinate[1];\n    return isLngDiff || isLatDiff;\n  }\n\n  _hasBoundsChanged(currentCamera, nextCamera) {\n    const cB = currentCamera.bounds;\n    const nB = nextCamera.bounds;\n\n    if (!cB && !nB) {\n      return false;\n    }\n\n    if (existenceChange(cB, nB)) {\n      return true;\n    }\n\n    return (\n      cB.ne[0] !== nB.ne[0] ||\n      cB.ne[1] !== nB.ne[1] ||\n      cB.sw[0] !== nB.sw[0] ||\n      cB.sw[1] !== nB.sw[1] ||\n      cB.paddingTop !== nB.paddingTop ||\n      cB.paddingLeft !== nB.paddingLeft ||\n      cB.paddingRight !== nB.paddingRight ||\n      cB.paddingBottom !== nB.paddingBottom\n    );\n  }\n\n  /**\n   * Map camera transitions to fit provided bounds\n   *\n   * @example\n   * this.camera.fitBounds([lng, lat], [lng, lat])\n   * this.camera.fitBounds([lng, lat], [lng, lat], 20, 1000) // padding for all sides\n   * this.camera.fitBounds([lng, lat], [lng, lat], [verticalPadding, horizontalPadding], 1000)\n   * this.camera.fitBounds([lng, lat], [lng, lat], [top, right, bottom, left], 1000)\n   *\n   * @param {Array<Number>} northEastCoordinates - North east coordinate of bound\n   * @param {Array<Number>} southWestCoordinates - South west coordinate of bound\n   * @param {Number=} padding - Camera padding for bound\n   * @param {Number=} animationDuration - Duration of camera animation\n   * @return {void}\n   */\n  fitBounds(\n    northEastCoordinates,\n    southWestCoordinates,\n    padding = 0,\n    animationDuration = 0.0,\n  ) {\n    const pad = {\n      paddingLeft: 0,\n      paddingRight: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n    };\n\n    if (Array.isArray(padding)) {\n      if (padding.length === 2) {\n        pad.paddingTop = padding[0];\n        pad.paddingBottom = padding[0];\n        pad.paddingLeft = padding[1];\n        pad.paddingRight = padding[1];\n      } else if (padding.length === 4) {\n        pad.paddingTop = padding[0];\n        pad.paddingRight = padding[1];\n        pad.paddingBottom = padding[2];\n        pad.paddingLeft = padding[3];\n      }\n    } else {\n      pad.paddingLeft = padding;\n      pad.paddingRight = padding;\n      pad.paddingTop = padding;\n      pad.paddingBottom = padding;\n    }\n\n    return this.setCamera({\n      bounds: {\n        ne: northEastCoordinates,\n        sw: southWestCoordinates,\n        ...pad,\n      },\n      animationDuration,\n      animationMode: Camera.Mode.Ease,\n    });\n  }\n\n  /**\n   * Map camera will fly to new coordinate\n   *\n   * @example\n   * this.camera.flyTo([lng, lat])\n   * this.camera.flyTo([lng, lat], 12000)\n   *\n   *  @param {Array<Number>} coordinates - Coordinates that map camera will jump too\n   *  @param {Number=} animationDuration - Duration of camera animation\n   *  @return {void}\n   */\n  flyTo(coordinates, animationDuration = 2000) {\n    return this.setCamera({\n      centerCoordinate: coordinates,\n      animationDuration,\n      animationMode: Camera.Mode.Flight,\n    });\n  }\n\n  /**\n   * Map camera will move to new coordinate at the same zoom level\n   *\n   * @example\n   * this.camera.moveTo([lng, lat], 200) // eases camera to new location based on duration\n   * this.camera.moveTo([lng, lat]) // snaps camera to new location without any easing\n   *\n   *  @param {Array<Number>} coordinates - Coordinates that map camera will move too\n   *  @param {Number=} animationDuration - Duration of camera animation\n   *  @return {void}\n   */\n  moveTo(coordinates, animationDuration = 0) {\n    return this._setCamera({\n      centerCoordinate: coordinates,\n      animationDuration,\n    });\n  }\n\n  /**\n   * Map camera will zoom to specified level\n   *\n   * @example\n   * this.camera.zoomTo(16)\n   * this.camera.zoomTo(16, 100)\n   *\n   * @param {Number} zoomLevel - Zoom level that the map camera will animate too\n   * @param {Number=} animationDuration - Duration of camera animation\n   * @return {void}\n   */\n  zoomTo(zoomLevel, animationDuration = 2000) {\n    return this._setCamera({\n      zoomLevel,\n      animationDuration,\n      animationMode: Camera.Mode.Flight,\n    });\n  }\n\n  /**\n   * Map camera will perform updates based on provided config. Advanced use only!\n   *\n   * @example\n   * this.camera.setCamera({\n   *   centerCoordinate: [lng, lat],\n   *   zoomLevel: 16,\n   *   animationDuration: 2000,\n   * })\n   *\n   * this.camera.setCamera({\n   *   stops: [\n   *     { pitch: 45, animationDuration: 200 },\n   *     { heading: 180, animationDuration: 300 },\n   *   ]\n   * })\n   *\n   *  @param {Object} config - Camera configuration\n   */\n  setCamera(config = {}) {\n    this._setCamera(config);\n  }\n\n  _setCamera(config = {}) {\n    let cameraConfig = {};\n\n    if (config.stops) {\n      cameraConfig.stops = [];\n\n      for (const stop of config.stops) {\n        cameraConfig.stops.push(this._createStopConfig(stop));\n      }\n    } else {\n      cameraConfig = this._createStopConfig(config);\n    }\n\n    this.refs.camera.setNativeProps({stop: cameraConfig});\n  }\n\n  _createDefaultCamera() {\n    if (this.defaultCamera) {\n      return this.defaultCamera;\n    }\n    if (!this.props.defaultSettings) {\n      return null;\n    }\n\n    this.defaultCamera = this._createStopConfig(\n      {\n        ...this.props.defaultSettings,\n        animationMode: Camera.Mode.Move,\n      },\n      true,\n    );\n    return this.defaultCamera;\n  }\n\n  _createStopConfig(config = {}, ignoreFollowUserLocation = false) {\n    if (this.props.followUserLocation && !ignoreFollowUserLocation) {\n      return null;\n    }\n\n    const stopConfig = {\n      mode: this._getNativeCameraMode(config),\n      pitch: config.pitch,\n      heading: config.heading,\n      duration: config.animationDuration || 0,\n      zoom: config.zoomLevel,\n    };\n\n    if (config.centerCoordinate) {\n      stopConfig.centerCoordinate = toJSONString(\n        geoUtils.makePoint(config.centerCoordinate),\n      );\n    }\n\n    if (config.bounds && config.bounds.ne && config.bounds.sw) {\n      const {ne, sw, paddingLeft, paddingRight, paddingTop, paddingBottom} =\n        config.bounds;\n      stopConfig.bounds = toJSONString(geoUtils.makeLatLngBounds(ne, sw));\n      stopConfig.boundsPaddingTop = paddingTop || 0;\n      stopConfig.boundsPaddingRight = paddingRight || 0;\n      stopConfig.boundsPaddingBottom = paddingBottom || 0;\n      stopConfig.boundsPaddingLeft = paddingLeft || 0;\n    }\n\n    return stopConfig;\n  }\n\n  _getNativeCameraMode(config) {\n    switch (config.animationMode) {\n      case Camera.Mode.Flight:\n        return MapboxGL.CameraModes.Flight;\n      case Camera.Mode.Move:\n        return MapboxGL.CameraModes.None;\n      case Camera.Mode.Linear:\n        return MapboxGL.CameraModes.Linear;\n      default:\n        return MapboxGL.CameraModes.Ease;\n    }\n  }\n\n  _getMaxBounds() {\n    const bounds = this.props.maxBounds;\n    if (!bounds || !bounds.ne || !bounds.sw) {\n      return null;\n    }\n    return toJSONString(geoUtils.makeLatLngBounds(bounds.ne, bounds.sw));\n  }\n\n  render() {\n    const props = Object.assign({}, this.props);\n\n    const callbacks = {\n      onUserTrackingModeChange: props.onUserTrackingModeChange,\n    };\n\n    return (\n      <RCTMGLCamera\n        testID=\"Camera\"\n        ref=\"camera\"\n        followUserLocation={this.props.followUserLocation}\n        followUserMode={this.props.followUserMode}\n        followPitch={this.props.followPitch}\n        followHeading={this.props.followHeading}\n        followZoomLevel={this.props.followZoomLevel}\n        stop={this._createStopConfig(props)}\n        maxZoomLevel={this.props.maxZoomLevel}\n        minZoomLevel={this.props.minZoomLevel}\n        maxBounds={this._getMaxBounds()}\n        defaultStop={this._createDefaultCamera()}\n        {...callbacks}\n      />\n    );\n  }\n}\n\nconst RCTMGLCamera = requireNativeComponent(NATIVE_MODULE_NAME, Camera, {\n  nativeOnly: {\n    stop: true,\n  },\n});\n\nCamera.UserTrackingModes = {\n  Follow: 'normal',\n  FollowWithHeading: 'compass',\n  FollowWithCourse: 'course',\n};\n\nexport default Camera;\n"]},"metadata":{},"sourceType":"module"}