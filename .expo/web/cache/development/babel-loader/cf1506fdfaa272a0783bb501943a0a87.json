{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { lineString, point, convertDistance as convertDistanceFn, convertLength as convertLengthFn } from '@turf/helpers';\nimport distance from '@turf/distance';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport length from '@turf/length';\nimport AnimatedCoordinatesArray from \"./AnimatedCoordinatesArray\";\nvar convertLength = convertLengthFn || convertDistanceFn;\n\nvar AnimatedRouteCoordinatesArray = function (_AnimatedCoordinatesA) {\n  _inherits(AnimatedRouteCoordinatesArray, _AnimatedCoordinatesA);\n\n  var _super = _createSuper(AnimatedRouteCoordinatesArray);\n\n  function AnimatedRouteCoordinatesArray() {\n    _classCallCheck(this, AnimatedRouteCoordinatesArray);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AnimatedRouteCoordinatesArray, [{\n    key: \"onInitialState\",\n    value: function onInitialState(coordinatesArray) {\n      return {\n        fullRoute: coordinatesArray.map(function (coord) {\n          return [coord[0], coord[1]];\n        }),\n        end: {\n          from: 0\n        }\n      };\n    }\n  }, {\n    key: \"onGetValue\",\n    value: function onGetValue(state) {\n      return state.actRoute || state.fullRoute;\n    }\n  }, {\n    key: \"onCalculate\",\n    value: function onCalculate(state, progress) {\n      var fullRoute = state.fullRoute,\n          end = state.end;\n      var currentEnd = end.from * (1.0 - progress) + progress * end.to;\n      var prevsum = 0;\n      var actsum = 0;\n      var i = fullRoute.length - 1;\n\n      while (actsum < currentEnd && i > 0) {\n        prevsum = actsum;\n        actsum += distance(point(fullRoute[i]), point(fullRoute[i - 1]), this.distconf);\n        i -= 1;\n      }\n\n      if (actsum <= currentEnd) {\n        var _actRoute = _toConsumableArray(fullRoute.slice(0, i + 1));\n\n        return {\n          fullRoute: fullRoute,\n          end: _objectSpread(_objectSpread({}, end), {}, {\n            current: currentEnd\n          }),\n          actRoute: _actRoute\n        };\n      }\n\n      var r = (currentEnd - prevsum) / (actsum - prevsum);\n      var or = 1.0 - r;\n      var actRoute = [].concat(_toConsumableArray(fullRoute.slice(0, i + 1)), [[fullRoute[i][0] * r + fullRoute[i + 1][0] * or, fullRoute[i][1] * r + fullRoute[i + 1][1] * or]]);\n      return {\n        fullRoute: fullRoute,\n        end: _objectSpread(_objectSpread({}, end), {}, {\n          current: currentEnd\n        }),\n        actRoute: actRoute\n      };\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart(state, toValue) {\n      var fullRoute = state.fullRoute,\n          end = state.end;\n      var toDist;\n\n      if (!toValue.end) {\n        console.error('RouteCoordinatesArray: toValue should have end with either along or point');\n      }\n\n      if (toValue.end.along != null) {\n        var units = toValue.units;\n        var ls = lineString(fullRoute);\n        toDist = convertLength(toValue.end.along, units);\n        toDist = length(ls) - toDist;\n      }\n\n      if (toDist != null) {\n        if (toValue.end.point) {\n          console.warn('RouteCoordinatesArray: toValue.end: has both along and point, point is ignored');\n        }\n      } else if (toValue.end.point) {\n        var _ls = lineString(fullRoute);\n\n        var nearest = nearestPointOnLine(_ls, toValue.end.point);\n        toDist = length(_ls) - nearest.properties.location;\n      } else {\n        console.warn('RouteCoordinatesArray: toValue.end: should have either along or point');\n      }\n\n      var result = {\n        fullRoute: fullRoute,\n        end: _objectSpread(_objectSpread({}, end), {}, {\n          from: end.current != null ? end.current : end.from,\n          to: toDist\n        })\n      };\n      return result;\n    }\n  }, {\n    key: \"originalRoute\",\n    get: function get() {\n      return this.state.fullRoute;\n    }\n  }]);\n\n  return AnimatedRouteCoordinatesArray;\n}(AnimatedCoordinatesArray);\n\nexport { AnimatedRouteCoordinatesArray as default };","map":{"version":3,"sources":["/Users/asha/Documents/miniboss/node_modules/@react-native-mapbox-gl/maps/javascript/utils/animated/AnimatedRouteCoordinatesArray.js"],"names":["lineString","point","convertDistance","convertDistanceFn","convertLength","convertLengthFn","distance","nearestPointOnLine","length","AnimatedCoordinatesArray","AnimatedRouteCoordinatesArray","coordinatesArray","fullRoute","map","coord","end","from","state","actRoute","progress","currentEnd","to","prevsum","actsum","i","distconf","slice","current","r","or","toValue","toDist","console","error","along","units","ls","warn","nearest","properties","location","result"],"mappings":"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","sourcesContent":["import {\n  lineString,\n  point,\n  convertDistance as convertDistanceFn,\n  convertLength as convertLengthFn,\n} from '@turf/helpers';\nimport distance from '@turf/distance';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport length from '@turf/length';\n\nimport AnimatedCoordinatesArray from './AnimatedCoordinatesArray';\n\nconst convertLength = convertLengthFn || convertDistanceFn;\n\nexport default class AnimatedRouteCoordinatesArray extends AnimatedCoordinatesArray {\n  /**\n   * Calculate initial state\n   *\n   * @param {*} args - to value from animate\n   * @returns {object} - the state object\n   */\n  onInitialState(coordinatesArray) {\n    return {\n      fullRoute: coordinatesArray.map((coord) => [coord[0], coord[1]]),\n      end: {from: 0},\n    };\n  }\n\n  /**\n   * Calculate value from state.\n   *\n   * @param {object} state - either state from initialState and/or from calculate\n   * @returns {object}\n   */\n  onGetValue(state) {\n    return state.actRoute || state.fullRoute;\n  }\n\n  /**\n   * Calculates state based on startingState and progress, returns a new state\n   *\n   * @param {object} state - state object from initialState and/or from calculate\n   * @param {number} progress - value between 0 and 1\n   * @returns {object} next state\n   */\n  onCalculate(state, progress) {\n    const {fullRoute, end} = state;\n    const currentEnd = end.from * (1.0 - progress) + progress * end.to;\n\n    let prevsum = 0;\n    let actsum = 0;\n    let i = fullRoute.length - 1;\n    while (actsum < currentEnd && i > 0) {\n      prevsum = actsum;\n      actsum += distance(\n        point(fullRoute[i]),\n        point(fullRoute[i - 1]),\n        this.distconf,\n      );\n      i -= 1;\n    }\n    if (actsum <= currentEnd) {\n      const actRoute = [...fullRoute.slice(0, i + 1)];\n      return {fullRoute, end: {...end, current: currentEnd}, actRoute};\n    }\n    const r = (currentEnd - prevsum) / (actsum - prevsum);\n    const or = 1.0 - r;\n\n    const actRoute = [\n      ...fullRoute.slice(0, i + 1),\n      [\n        fullRoute[i][0] * r + fullRoute[i + 1][0] * or,\n        fullRoute[i][1] * r + fullRoute[i + 1][1] * or,\n      ],\n    ];\n    return {fullRoute, end: {...end, current: currentEnd}, actRoute};\n  }\n\n  /**\n   * Subclasses can override to start a new animation\n   *\n   * @param {*} toValue - to value from animate\n   * @param {*} actCoords - the current coordinates array to start from\n   * @returns {object} The state\n   */\n  onStart(state, toValue) {\n    const {fullRoute, end} = state;\n    let toDist;\n    if (!toValue.end) {\n      console.error(\n        'RouteCoordinatesArray: toValue should have end with either along or point',\n      );\n    }\n    if (toValue.end.along != null) {\n      const {units} = toValue;\n      const ls = lineString(fullRoute);\n      toDist = convertLength(toValue.end.along, units);\n      toDist = length(ls) - toDist;\n    }\n    if (toDist != null) {\n      if (toValue.end.point) {\n        console.warn(\n          'RouteCoordinatesArray: toValue.end: has both along and point, point is ignored',\n        );\n      }\n    } else if (toValue.end.point) {\n      const ls = lineString(fullRoute);\n\n      const nearest = nearestPointOnLine(ls, toValue.end.point);\n      toDist = length(ls) - nearest.properties.location;\n    } else {\n      console.warn(\n        'RouteCoordinatesArray: toValue.end: should have either along or point',\n      );\n    }\n\n    const result = {\n      fullRoute,\n      end: {\n        ...end,\n        from: end.current != null ? end.current : end.from,\n        to: toDist,\n      },\n    };\n    return result;\n  }\n\n  get originalRoute() {\n    return this.state.fullRoute;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}